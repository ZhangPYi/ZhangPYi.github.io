GPU虚拟化技术

一、GPU概述


GPU的英文名称为Graphic Processing Unit，GPU中文全称为计算机图形处理器，由1999 年NVIDIA 公司提出。GPU这一概念也是相对于计算机系统中的CPU而言的，由于人们对图形的需求越来越大，尤其是在家用系统和游戏发烧友，而传统的CPU不能满足现状，因此需要提供一个专门处理图形的核心处理器。GPU 作为硬件显卡的“心脏”，地位等同于CPU在计算机系统中的作用。同时GPU也可以用来作为区分2D硬件显卡和3D硬件显卡的重要依据。2D硬件显卡主要通过使用CPU 来处理特性和3D 图像，将其称作“软加速”。3D 硬件显卡则是把特性和3D 图像的处理能力集中到硬件显卡中，也就是“硬件加速”。目前市场上流行的显卡多半是由NVIDIA 及ATI这两家公司生产的。

1.1、为什么需要专门出现GPU来处理图形工作，CPU为啥不可以？


GPU 是并行编程模型，和CPU的串行编程模型完全不同，导致很多CPU 上优秀的算法都无法直接映射到GPU 上，并且GPU的结构相当于共享存储式多处理结构，因此在GPU上设计的并行程序与CPU 上的串行程序具有很大的差异。GPU主要采用立方环境的材质贴图、硬体T&L、顶点混合、凹凸的映射贴图和纹理压缩、双重纹理四像素256 位的渲染引擎等重要技术。由于图形渲染任务具有高度的并行性，因此GPU可以仅仅通过增加并行处理单元和存储器控制单元便可有效的提高处理能力和存储器带宽。GPU设计目的和CPU截然不同，CPU是设计用来处理通用任务，因此具有复杂的控制单元，而GPU主要用来处理计算性强而逻辑性不强的计算任务，GPU中可利用的处理单元可以更多的作为执行单元。因此，相较于CPU，GPU在具备大量重复数据集运算和频繁内存访问等特点的应用场景中具有无可比拟的优势。


1.2、GPU如何使用？


使用GPU有两种方式，一种是开发的应用程序通过通用的图形库接口调用GPU设备，另一种是GPU自身提供API编程接口，应用程序通过GPU提供的API编程接口直接调用GPU设备。


1.2.1、通用图形库


  通过通用的图形库的方式使用GPU，都是通过 OpenGL 或Direct3D这一类现有的图形函数库，以编写渲染语言(shading language)的方法控制 GPU 内部的渲染器(shader)来完成需要的计算。

目前业界公认的图形编程接口主要有OpenGL和DirectX这两种接口。OpenGL是当前可用于开发可交互、可移植的2D与3D图形应用程序的首选环境，也是当前图形应用最广泛的标准。OpenGL是SGI公司开发的计算机图形处理系统，是图形硬件的软件接口，GL为图形库(Graphics Library)，OpenGL应用程序不需要关注所在运行环境所处的操作系统与平台。只要在任何一个遵循OpenGL标准的环境下都会产生一样的可视化效果。与OpenGL 类似，DirectX(DirecteXtension)也是一种图形API。它是由Microsoft创建的多媒体编程接口，并已经成为微软视窗的标准。为适应GPU应用的需求,DirectX则根据GPU新产品功能的扩充与进展及时地定义新的版本，它所提供的功能几乎与GPU提供的功能同步。


1.2.2、GPU自身编程接口


GPU自身提供的编程接口主要由提供GPU设备的两家公司提供，分别是括NVIDIA 的CUDA 框架和AMD(ATI)公司于2006年提出了CTM(Close ToMetal)框架（备注，最初是ATI公司生产GPU设备，后被AMD收购）。AMD的CTM框架现在已不在使用，主要是AMD(ATI)于2007 年推出了ATI Stream SDK架构，2008 年AMD(ATI)完全转向了公开的OpenCL标准，因此AMD(ATI)公司目前已没有独立的、私有的通用计算框架。

CUDA(ComputeUnified Device Architecture)是在2007 年6 月由NVIDIA公司发布的专用通用计算框架。使用CUDA进行通用计算编程不再需要借助图形学API，而是使用与C语言十分类似的方式进行开发。在CUDA编程模型中，有一个被称为主机(Host)的CPU 和若干个被称作设备(Device)或者协处理器(Co-Processor)的GPU。在该模型中，CPU 和GPU 协同工作，各司其职。CPU负责进行逻辑性较强的事务处理和串行计算，而GPU 则专注于执行线程化的并行处理任务。CPU、GPU各自拥有相互独立的存储器地址空间主机端的内存和设备端的显存。一般采用CUDA框架自己进行编程的都一些大型的应用程序，比如石油勘测、流体力学模拟、分子动力学仿真、生物计算、音视频编解码、天文计算等领域。而我们一般企业级的应用程序由于开发成本以及兼容性等原因，大多数都是采用通用的图形库来进行开发调用GPU设备。


1.3、GPU如何工作？


GPU 对于通用计算和图形处理的内部组件主要有两部分:顶点处理器(vertex processor)和子素处理器(fragment processor)。这种处理器具备流处理机的模式，即不具有大容量的快存/存储器可以读写,只是直接在芯片上利用临时寄存器进行流数据的操作。

 

当GPU 用于图形处理时，此时GPU 内部的顶点渲染、像素渲染以及几何渲染操作都可以通过流处理器完成。从图中可以看出，此时GPU 内部的所有流处理器相当于一个多核的处理器，数据可以很方便的在不同的流处理器之间的输入和输出之间移动，同时GPU分派器和控制逻辑可以动态的指派流处理器进行相应的顶点，像素，几何等操作，因为流处理器都是通用的。


二、GPU虚拟化


开始我们的正题，目前虚拟机系统中的图形处理方式有三种：一种是采用虚拟显卡的方式，另一种是直接采用物理显卡，最后是采用GPU虚拟化。


2.1、虚拟显卡


第一种采用虚拟显卡是现在主流的虚拟化系统的选择，因为专业的显卡硬件价格不菲。目前采用虚拟显卡的这些技术包括：虚拟网络计算机VNC(Virtual Network Computing)，Xen 虚拟帧缓存，VMware虚拟图形显示处理器GPU(Graphics Processing Unit)以及独立于虚拟机管理器的图形加速系统VMGL(VMM-Independent Graphics Acceleration)。

VNC(VirtualNetwork Computing)基本上是属于一种显示系统,也就是说它能将完整的窗口界面通过网络，传输到另一台计算机的屏幕上。Windows 服务器中包含的"Terminal Server"即是属于这种原理的设计。VNC 是由AT&T 实验室所开发的，其采用GPL(General PublicLicense)授权条款，任何人都可免费取得该软件。VNC软件要由两个部分组成：VNC server 及VNC viewer。用户需先将VNC server安装在被远程操控的计算机上后，才能在主控端执行VNC viewer 进行远程操控。

XEN虚拟帧缓存是指XEN提供的一个虚拟的显示设备。该虚拟显示设备采用特权域的VNC服务器，因此该虚拟显示设备具有相似的VNC接口。客户机在XEN虚拟帧缓存中写入数据，然后通过VNC 协议来传输已修改的图片，最后通知前端进行相应区域的更新。这个虚拟帧缓存设备的源码是来自开源的Qemu。我们在XenServer上看见虚拟机的操作系统桌面界面，即是这种技术的显示。

虚拟网络计算机VNC 和XEN 虚拟帧缓存这两种模式至今在虚拟机中仍未提供一定的硬件图形加速能力。由于目前仍没有一个机制能使虚拟机进行访问图形硬件的能力，因此这些虚拟的显示设备都是通过使用CPU以及内存的方式对图形数据进行相应处理。并没有采用物理显示设备的功能。然而VMGL这种模式已经实现了这种机制，这个机制通常被称为前端-后端虚拟化机制(front-end virtualization)。VMGL这种模式采用这个机制将需要图形处理的数据发送到一个拥有硬件图形加速功能的虚拟监控机上进行相应的图形数据处理。目前存在的比较主流可用于GPU应用程序开发的图形处理接口有两类：OpenGL 和Direct3D。在这两类图形处理接口中，OpenGL是唯一一类能够在主流操作系统中跨平台操作的图形API接口。在虚拟机平台中，VMGL是首个针对OpenGL API进行虚拟化的项目。VMGL的工作原理是，它在客户端操作系统中部署了一个伪库(Fake library)用来取代标准的OPENGL 库，伪库(Fake library)拥有与标准的OPENG库相同的接口，在客户端操作系统中的伪库也实现了指向远程服务器的宿主机操作系统的远程调用。这样一来，所有的本地OPENGL调用都将被解释为对远程服务器的一次服务请求，远程服务器的宿主机操作系统拥有真正的OPENGL库、显卡驱动和物理硬件GPU，它负责完成OPENGL请求并将执行结果显示到屏幕上。由于VMGL在整个过程操作中都是完全透明的，因此调用OPENGL的应用程序不需要修改源代码也不需要进行二进制改写，无需为虚拟机平台作任何改动。


2.2、显卡直通

显卡直通也叫做显卡穿透(pass-through)，是指绕过虚拟机管理系统，将GPU 单独分配给某一虚拟机，只有该虚拟机拥有使用GPU的权限，这种独占设备的方法分配方式保存了GPU的完整性和独立性，在性能方面与非虚拟化条件下接近，且可以用来进行通用计算。但是显卡直通需要利用显卡的一些特殊细节，同时兼容性差，仅在部分GPU 中设备可以使用。Xen 4.0增加了VGA passthrough技术，因此XenServer也拥有了该技术，XenServer的Passthrough 就是利用英特尔设备虚拟化（Intel VT-d）技术将显示设备暴露给某一个客户虚拟机，不仅其它客户虚拟机不能访问，就连宿主虚拟机也失去了使用该GPU的能力。它在客户虚拟机中实现了显卡的一些特殊细节，如VGA BIOS、文本模式、IO 端口、内存映射、VESA模式等，以支持直接访问。使用XenServer的 VGA Passthrough 技术的GPU执行效率高，功能全，但只能被单一系统独占使用，失去了设备复用的功能。VMwareESX 中包括一个VMDirectPath I/O框架，使用该技术也可以将我们的显卡设备直通给某一虚拟机进行使用。XenServer和VMware使用的是不同的技术但是实现的效果都是一样的，即将物理显卡设备直通给其中的某一虚拟机使用，以达到虚拟机进行3D显示和渲染的效果。

由于显卡直通实际上是由客户操作系统使用原生驱动和硬件，缺少必要的中间层来跟踪和维护GPU 状态，它不支持实时迁移等虚拟机高级特性。如XenServer Passthrough禁止执行save/restore/migration 等操作。VMware的虚拟机中，一旦开启VMDirectPath I/O功能，其对应的虚拟机将失去执行挂起/恢复、实时迁移的能力。


2.3、显卡虚拟化（GPU虚拟化）

显卡虚拟化就是将显卡进行切片，并将这些显卡时间片分配给虚拟机使用的过程。由于支持显卡虚拟化的显卡一般可以根据需要切分成不同的规格的时间片，因此可以分配给多台虚拟机使用。其实现原理其实就是利用应用层接口虚拟化(API remoting)，API重定向是指在应用层进行拦截与GPU相关的应用程序编程接口(Application ProgrammingInterface，API)，通过重定向（仍然使用GPU）的方式完成相应功能，再将执行结果返回应用程序。

我们现在使用3D桌面虚拟化解决方案中，大部分是使用NVIDIA公司提供的显卡虚拟化技术，即是vCUDA(virtual CUDA)技术，前面我们说过了CUDA框架。vCUDA采用在用户层拦截和重定向CUDA API的方法，在虚拟机中建立物理GPU的逻辑映像――虚拟GPU，实现GPU资源的细粒度划分、重组和再利用，支持多机并发、挂起恢复等虚拟机高级特性。

其vCUDA的实现原理大概如下：包括三个模块：CUDA客户端、CUDA服务端和CUDA管理端。以XenServer为例，在物理硬件资源上运行着一个VMM用于向上提供硬件映像，在VMM上运行着若干个虚拟机。其中一个虚拟机为特权虚拟机(Host VM)，即为XenServer中的Domain 0，在虚拟机中运行的操作系统称为Host OS。Host OS能够直接控制硬件，系统内安装着原生的CUDA库以及GPU驱动，使得Host OS可以直接访问GPU和使用CUDA。其它的虚拟机属于非特权虚拟机(Guest VM)，其上运行的操作系统(Guest OS)不能直接操纵GPU。在这里我们将CUDA客户端称之为客户端驱动，CUDA服务端称之为宿主机的驱动，CUDA管理端称之为GPU管理器。


2.3.1、客户端

客户端驱动其实质就是我们安装在虚拟机比如Windows 7上的显卡驱动程序。主要的功能是在用户层提供针对CUDA API的库以及一个维护CUDA相关软硬件状态的虚拟GPU(vGPU)。客户端驱动直接面向CUDA应用程序，其作用包括：

 
  1)拦截应用程序中CUDA API调用；


  2)选择通信策略，为虚拟化提供更高层语义的支持；

 
  3)对调用的接口和参数进行封装、编码；


  4)对服务端返回的数据进行解码，并返回给应用。


此外，客户端驱动在第一个API调用到来之前，首先到管理端索取GPU资源。每一个独立的调用过程都必须到宿主管理端驱动申请资源，以实现对GPU资源和任务的实时调度。

此外，客户端驱动同时设置了vGPU用来维护与显卡相关的软硬件状态。vGPU本身实质上仅仅是一个键值对的数据结构，在其中存储了当前使用的地址空间、显存对象、内存对象等，同时记录了API的调用次序。当计算结果返回时，客户端驱动会根据结果更新vGPU。


2.3.2、服务器端


服务端组件位于特权虚拟机(XenServer术语：特权域)中的应用层。特权虚拟机可以直接与硬件交互，因此服务端组件可以直接操纵物理GPU来完成通用计算任务。


服务端面向真实GPU，其作用包括：

 
  1)接收客户端的数据报，并解析出调用和参数；


  2)对调用和参数进行审核；


  3)利用CUDA和物理GPU计算审核通过的调用；


  4)将结果编码，并返回给客户端；


  5)对计算系统中支持CUDA的GPU进行管理。


此外，服务端运行的第一个任务是将自身支持CUDA的GPU设备的信息注册到管理端中。服务端应对客户端的请求时，为每个应用分配独立的服务线程。服务端统一管理本地GPU资源，按照一定的策略提供GPU资源，并将由于API调用修改的相关软硬件状态更新至vGPU。


2.3.3、管理端


管理端组件位于特权域，在实现CUDA编程接口虚拟化的基础上，将GPU强大的计算能力和计算资源在更高的逻辑层次上进行隔离、划分、调度。在CUDA服务端使用计算线程和工作线程在一定程度上使同在一个物理机上的GPU间负载均衡，设置CUDA管理端组件在更高的逻辑层次上进行负载均衡，使在同一个GPU虚拟集群中的GPU负载均衡。管理端组件

调度的原则是尽量使在同一个物理机上的GPU需求自给，如果该物理机上具备满足条件的GPU资源，在一般情况下，该物理机上的虚拟机的GPU需求都重定向到该物理机的CUDA服务端。


理端对GPU资源进行统一管理，采用集中、灵活的机制，实现：


  1)动态调度：当用户所占资源空闲时间超过一定阈值或者任务结束时，管理端回收该资源，当该用户再次发布计算任务时，重新为其任务分配GPU资源；

 
  2)负载平衡：当局部计算压力过大时，调整计算负载，通过动态调度时选择合适的GPU资源来分散计算负载；


  3)故障恢复：当出现故障时，将任务转移到新的可用GPU资源上。
  

----------

2018-03-16 09:42

张朋艺 pyZhangBIT2010@126.com